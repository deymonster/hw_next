#!/usr/bin/env bash
set -euo pipefail

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
ENV_FILE="${PROJECT_ROOT}/.env"
COMPOSE_FILE="${PROJECT_ROOT}/docker-compose.dev.yml"
HTPASSWD_FILE="${PROJECT_ROOT}/nginx/auth/.htpasswd"
LOG_DIR="${PROJECT_ROOT}/storage/logs"
UPLOAD_DIR="${PROJECT_ROOT}/storage/uploads"

SERVER_HOST="localhost"
ADMIN_EMAIL="admin@example.com"
START_NEXT="false"
SKIP_YARN="false"

usage() {
        cat <<USAGE
Usage: $(basename "$0") [options]

Options:
  --host <host>           Hostname or IP exposed to the browser (default: localhost)
  --admin-email <email>   Administrator email used for the seeded account (default: admin@example.com)
  --start-next            Start the Next.js development server after Docker services
  --skip-yarn             Skip yarn install/migrate steps (when working inside containers only)
  -h, --help              Show this help message
USAGE
}

while [[ $# -gt 0 ]]; do
        case "$1" in
        --host)
                SERVER_HOST="$2"
                shift 2
                ;;
        --admin-email)
                ADMIN_EMAIL="$2"
                shift 2
                ;;
        --start-next)
                START_NEXT="true"
                shift 1
                ;;
        --skip-yarn)
                SKIP_YARN="true"
                shift 1
                ;;
        -h | --help)
                usage
                exit 0
                ;;
        *)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
        esac
done

require_command() {
        if ! command -v "$1" >/dev/null 2>&1; then
                echo "‚ùå Required command '$1' not found. Please install it first." >&2
                exit 1
        fi
}

random_hex() {
        if command -v openssl >/dev/null 2>&1; then
                openssl rand -hex "$1"
        else
                head -c "$1" /dev/urandom | od -An -tx1 | tr -d ' \n'
        fi
}

random_b64() {
        if command -v openssl >/dev/null 2>&1; then
                openssl rand -base64 32 | tr -d '\n'
        else
                head -c 32 /dev/urandom | base64 | tr -d '\n'
        fi
}

get_env_value() {
        local key="$1"
        if [[ -f "$ENV_FILE" ]]; then
                grep -E "^${key}=" "$ENV_FILE" | tail -n1 | cut -d= -f2- || true
        fi
}

ensure_env_file() {
        echo "üìÑ Preparing .env file at $ENV_FILE"

        local postgres_user postgres_password postgres_db postgres_port redis_password redis_port
        local prometheus_password nextauth_secret encryption_key agent_key

        postgres_user="${POSTGRES_USER:-$(get_env_value POSTGRES_USER)}"
        postgres_user="${postgres_user:-hw_monitor}"

        postgres_password="${POSTGRES_PASSWORD:-$(get_env_value POSTGRES_PASSWORD)}"
        postgres_password="${postgres_password:-$(random_hex 12)}"

        postgres_db="${POSTGRES_DB:-$(get_env_value POSTGRES_DB)}"
        postgres_db="${postgres_db:-hw_monitor}"

        postgres_port="${POSTGRES_PORT:-$(get_env_value POSTGRES_PORT)}"
        postgres_port="${postgres_port:-5432}"

        redis_password="${REDIS_PASSWORD:-$(get_env_value REDIS_PASSWORD)}"
        redis_password="${redis_password:-$(random_hex 12)}"

        redis_port="${REDIS_PORT:-$(get_env_value REDIS_PORT)}"
        redis_port="${redis_port:-6379}"

        prometheus_password="${PROMETHEUS_AUTH_PASSWORD:-$(get_env_value PROMETHEUS_AUTH_PASSWORD)}"
        prometheus_password="${prometheus_password:-$(random_hex 12)}"

        nextauth_secret="${NEXTAUTH_SECRET:-$(get_env_value NEXTAUTH_SECRET)}"
        nextauth_secret="${nextauth_secret:-$(random_b64)}"

        encryption_key="${ENCRYPTION_KEY:-$(get_env_value ENCRYPTION_KEY)}"
        encryption_key="${encryption_key:-$(random_hex 32)}"

        agent_key="${AGENT_HANDSHAKE_KEY:-$(get_env_value AGENT_HANDSHAKE_KEY)}"
        agent_key="${agent_key:-$(random_hex 32)}"

        cat >"$ENV_FILE" <<EOF
# Autogenerated by setup-local.sh
# Core URLs
NEXT_PUBLIC_BASE_URL=http://${SERVER_HOST}:3000
NEXT_PUBLIC_SERVER_IP=${SERVER_HOST}
NEXT_PUBLIC_URL=http://${SERVER_HOST}:3000
NEXTAUTH_URL=http://${SERVER_HOST}:3000
NEXT_PUBLIC_STORAGE_URL=http://${SERVER_HOST}:8081
NEXT_PUBLIC_UPLOADS_BASE_URL=http://${SERVER_HOST}:8081
NEXT_PUBLIC_MEDIA_URL=http://${SERVER_HOST}:8081

# PostgreSQL
POSTGRES_USER=${postgres_user}
POSTGRES_PASSWORD=${postgres_password}
POSTGRES_DB=${postgres_db}
POSTGRES_HOST=127.0.0.1
POSTGRES_PORT=${postgres_port}
DATABASE_URL=postgresql://${postgres_user}:${postgres_password}@127.0.0.1:${postgres_port}/${postgres_db}

# Redis
REDIS_HOST=127.0.0.1
REDIS_PORT=${redis_port}
REDIS_PASSWORD=${redis_password}
REDIS_URL=redis://:${redis_password}@127.0.0.1:${redis_port}

# Prometheus
PROMETHEUS_PORT=9090
PROMETHEUS_PROXY_URL=http://${SERVER_HOST}:8080
PROMETHEUS_TARGETS_PATH=./prometheus/targets/windows_targets.json
PROMETHEUS_USERNAME=admin
PROMETHEUS_AUTH_PASSWORD=${prometheus_password}
PROMETHEUS_RULES_PATH=./prometheus/alerts

# Node exporter
NODE_EXPORTER_PORT=9100

# Telegram
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=
ADMIN_TELEGRAM_CHAT_ID=

# Admin account
ADMIN_USERNAME=admin
ADMIN_PASSWORD=admin123
ADMIN_EMAIL=${ADMIN_EMAIL}

# Agents
AGENT_HANDSHAKE_KEY=${agent_key}
HANDSHAKE_KEY=${agent_key}

# Application
NODE_ENV=development
NEXTAUTH_SECRET=${nextauth_secret}
ENCRYPTION_KEY=${encryption_key}
DEBUG_MODE=false
LICD_URL=http://${SERVER_HOST}:8082

# SMTP (placeholder values for local development)
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=demo@example.com
SMTP_PASSWORD=demo-password
SMTP_FROM_EMAIL=demo@example.com
SMTP_FROM_NAME="HW Monitor"
EOF

        POSTGRES_USER_VALUE="$postgres_user"
        POSTGRES_PORT_VALUE="$postgres_port"
        REDIS_PORT_VALUE="$redis_port"
}

ensure_directories() {
        mkdir -p "$LOG_DIR" "$UPLOAD_DIR" "$(dirname "$HTPASSWD_FILE")"
        chmod 775 "$LOG_DIR" "$UPLOAD_DIR" || true
}

ensure_htpasswd() {
        local user pass hash
        user="$(get_env_value PROMETHEUS_USERNAME)"
        user="${user:-admin}"
        pass="$(get_env_value PROMETHEUS_AUTH_PASSWORD)"
        pass="${pass:-admin}"

        if command -v openssl >/dev/null 2>&1; then
                hash="$(openssl passwd -apr1 "$pass")"
        elif command -v htpasswd >/dev/null 2>&1; then
                hash="$(htpasswd -nb "$user" "$pass" | cut -d: -f2-)"
        else
                echo "‚ö†Ô∏è  Neither openssl nor htpasswd is available. Using clear-text basic auth." >&2
                hash="$pass"
        fi

        echo "${user}:${hash}" >"$HTPASSWD_FILE"
}

detect_compose() {
        if docker compose version >/dev/null 2>&1; then
                echo "docker compose"
        elif docker-compose version >/dev/null 2>&1; then
                echo "docker-compose"
        else
                echo "‚ùå Neither 'docker compose' nor 'docker-compose' is installed." >&2
                exit 1
        fi
}

start_docker_services() {
        local compose_cmd
        compose_cmd="$(detect_compose)"

        echo "üê≥ Starting Docker services using $(basename "$COMPOSE_FILE")"
        (cd "$PROJECT_ROOT" && $compose_cmd -f "$COMPOSE_FILE" up -d --build)

        echo "‚è≥ Waiting for PostgreSQL to be ready..."
        local retries=0
        local pg_user
        pg_user="${POSTGRES_USER_VALUE:-$(get_env_value POSTGRES_USER)}"
        while ! (cd "$PROJECT_ROOT" && $compose_cmd -f "$COMPOSE_FILE" exec -T postgres pg_isready -U "$pg_user" >/dev/null 2>&1); do
                sleep 2
                retries=$((retries + 1))
                if [[ $retries -ge 30 ]]; then
                        echo "‚ö†Ô∏è  PostgreSQL did not become ready in time. Continuing anyway." >&2
                        break
                fi
        done
}

run_yarn_tasks() {
        if [[ "$SKIP_YARN" == "true" ]]; then
                echo "‚è≠Ô∏è  Skipping yarn steps as requested."
                return
        fi

        if ! command -v yarn >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  Yarn is not installed; skipping frontend dependency setup."
                return
        fi

        echo "üì¶ Installing frontend dependencies"
        (cd "$PROJECT_ROOT" && yarn install)

        echo "üõ†Ô∏è  Generating Prisma client"
        (cd "$PROJECT_ROOT" && yarn prisma generate)

        echo "üóÉÔ∏è  Applying database migrations"
        (cd "$PROJECT_ROOT" && yarn prisma migrate deploy)
}

start_next_dev() {
        if [[ "$START_NEXT" != "true" ]]; then
                echo "‚ÑπÔ∏è  Next.js dev server not started automatically. Run 'yarn dev --hostname 0.0.0.0' when ready."
                return
        fi

        if ! command -v yarn >/dev/null 2>&1; then
                echo "‚ö†Ô∏è  Yarn is not available; cannot start Next.js dev server automatically."
                return
        fi

        echo "üöÄ Starting Next.js development server (Ctrl+C to stop)"
        (cd "$PROJECT_ROOT" && yarn dev --hostname 0.0.0.0)
}

main() {
        require_command docker
        ensure_env_file
        ensure_directories
        ensure_htpasswd
        start_docker_services
        run_yarn_tasks
        start_next_dev

        echo "‚úÖ Local environment is ready!"
        echo "Services:"
        echo "  UI:             http://${SERVER_HOST}:3000"
        echo "  PostgreSQL:     127.0.0.1:${POSTGRES_PORT_VALUE:-5432}"
        echo "  Redis:          127.0.0.1:${REDIS_PORT_VALUE:-6379}"
        echo "  Prometheus:     http://${SERVER_HOST}:9090"
        echo "  Alertmanager:   http://${SERVER_HOST}:9093"
        echo "  Nginx proxy:    http://${SERVER_HOST}:8080"
        echo "  File storage:   http://${SERVER_HOST}:8081"
        echo "  LICD service:   http://${SERVER_HOST}:8082"
}

main "$@"
